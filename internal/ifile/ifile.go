package ifile

import (
	"bytes"
	"fmt"
	"io"
	"os"
	"path/filepath"
	"strings"
	"sync"

	pathspec "github.com/karagenc/go-pathspec"
	"go.uber.org/zap"
)

type (
	Ifile struct {
		log  *zap.Logger
		logS *zap.SugaredLogger
		mode Mode

		buf   bytes.Buffer
		bufMu sync.Mutex
		end   []byte

		filePath         string
		file             *os.File
		appendToExisting bool
		once             sync.Once
	}

	entry struct {
		path  string
		isDir bool
	}
	entries []*entry

	ignorefile struct {
		p   *pathspec.PathSpec
		dir string
	}

	Mode int
)

const (
	// Include file. Paths are absolute.
	ModeRestic Mode = iota
	// Ignore file. Paths are relative to the .gitignore/.kopyatignore.
	ModeSyncthing
)

func (m Mode) String() string {
	switch m {
	case ModeRestic:
		return "restic"
	case ModeSyncthing:
		return "syncthing"
	default:
		return "<invalid mode>"
	}
}

const (
	generatedBy    = "# Generated by kopyat. DO NOT TOUCH THE LINES BETWEEN I_BEGIN AND I_END."
	beginIndicator = "# I_BEGIN"
	endIndicator   = "# I_END"
)

func New(
	filePath string,
	mode Mode,
	appendToExisting bool,
	log *zap.Logger,
) (ifile *Ifile, err error) {
	ifile = &Ifile{
		log:              log,
		logS:             log.Sugar(),
		mode:             mode,
		filePath:         filePath,
		appendToExisting: appendToExisting,
	}

	flags := os.O_CREATE | os.O_RDWR
	ifile.file, err = os.OpenFile(ifile.filePath, flags, 0660)
	if err != nil {
		return nil, err
	}

	if ifile.appendToExisting {
		err = ifile.prepareExisting()
		if err != nil {
			return nil, err
		}
	} else {
		ifile.buf.WriteString(generatedBy + "\n")
		ifile.buf.WriteString(beginIndicator + "\n")
		ifile.end = append(ifile.end, []byte(endIndicator+"\n")...)
	}
	return
}

func (i *Ifile) prepareExisting() error {
	content, err := io.ReadAll(i.file)
	if err != nil {
		return err
	}

	content = bytes.ReplaceAll(content, []byte{'\r', '\n'}, []byte{'\n'})
	splitted := bytes.Split(content, []byte{'\n'})

	begin := -1
	end := -1
	c := 0

	for _, line := range splitted {
		if bytes.Equal(line, []byte(endIndicator)) {
			end = c
			break
		} else if bytes.Equal(line, []byte(beginIndicator)) {
			begin = c
		}
		c += len(line) + 1
	}

	if begin == -1 && end != -1 {
		return fmt.Errorf("ifile begin indicator ('%s') not found", beginIndicator)
	} else if end == -1 && begin != -1 {
		return fmt.Errorf("ifile end indicator ('%s') not found", endIndicator)
	}

	i.logS.Debugf("ifile: %s: begin %d, end %d", i.filePath, begin, end)

	if begin == -1 && end == -1 {
		i.buf.Write(content)
		i.buf.WriteString(generatedBy + "\n")
		i.buf.WriteString(beginIndicator + "\n")
		i.end = append(i.end, []byte(endIndicator+"\n")...)
	} else {
		i.buf.Write(content[:begin+len(beginIndicator)])
		i.buf.WriteString("\n")
		i.end = content[end:]
	}
	return nil
}

func (i *Ifile) Close() (err error) {
	var (
		err1 error
		err2 error
	)
	i.once.Do(func() {
		if i.appendToExisting {
			_, err = i.file.Seek(0, io.SeekStart)
			if err != nil {
				return
			}
			err = i.file.Truncate(0)
			if err != nil {
				return
			}
		}
		i.logS.Debugf("ifile: %s: writing i.buf", i.filePath)
		_, err1 = i.file.Write(i.buf.Bytes())
		if len(i.end) != 0 {
			i.logS.Debugf("ifile: %s: writing i.end", i.filePath)
			_, err2 = i.file.Write(i.end)
		} else {
			i.logS.Debugf("ifile: %s: writing newline", i.filePath)
			_, err2 = i.file.WriteString("\n")
		}
		i.file.Close()
	})

	// Prioritize err1
	if err1 != nil {
		i.logS.Debugf("ifile: %s: err1 occured", i.filePath)
		err = err1
	} else if err2 != nil {
		i.logS.Debugf("ifile: %s: err2 occured", i.filePath)
		err = err2
	}
	return
}

func (e *entry) Len() int {
	// + 1 is for newline; + 10 is for potential '\[' and '\]'
	return len(e.path) + 1 + 10
}

func (e *entry) String() string {
	s := e.path + "\n"
	s = strings.ReplaceAll(s, "[", "\\[")
	s = strings.ReplaceAll(s, "]", "\\]")
	s = filepath.ToSlash(s)
	return s
}
